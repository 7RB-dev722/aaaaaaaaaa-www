/*
# [Feature] Product Key Management System
This migration sets up the necessary database structures for managing product keys, including a table to store keys and a function to safely claim them.

## Query Description:
This script creates a new table `product_keys` and a function `claim_available_key`. It will not affect any existing data as it only adds new objects. It's safe to run on the existing database.

## Metadata:
- Schema-Category: "Structural"
- Impact-Level: "Low"
- Requires-Backup: false
- Reversible: true (by dropping the table and function)

## Structure Details:
- Tables Added: `public.product_keys`
- Functions Added: `public.claim_available_key`
- Columns: `id`, `created_at`, `product_id`, `key_value`, `is_used`, `used_by_email`, `used_at`, `purchase_intent_id`
- Indexes: Primary key on `id`, foreign key on `product_id`, unique index on `key_value`.

## Security Implications:
- RLS Status: Enabled on `product_keys`.
- Policy Changes: New policies are created for `product_keys` to allow reads for authenticated users and restrict modifications to the service role.
- Auth Requirements: Operations are handled via backend logic (RPC function), ensuring security.

## Performance Impact:
- Indexes: Adds indexes which will improve query performance on the new table.
- Triggers: None.
- Estimated Impact: Low, as it only affects new functionality.
*/

-- 1. Create product_keys table
create table if not exists public.product_keys (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone not null default now(),
    product_id uuid not null references public.products(id) on delete cascade,
    key_value text not null,
    is_used boolean not null default false,
    used_by_email text null,
    used_at timestamp with time zone null,
    purchase_intent_id uuid null references public.purchase_intents(id) on delete set null
);

-- Add a unique constraint to prevent duplicate keys
alter table public.product_keys add constraint product_keys_key_value_key unique (key_value);

-- 2. Enable RLS
alter table public.product_keys enable row level security;

-- 3. Create RLS policies
-- Allow admin users (service_role) to do everything
create policy "Allow full access to service_role"
on public.product_keys
for all
to service_role
using (true)
with check (true);

-- 4. Create the function to claim a key
create or replace function public.claim_available_key(p_product_id uuid, p_email text, p_intent_id uuid)
returns text
language plpgsql
security definer -- Important: allows the function to bypass RLS to update the table
as $$
declare
  claimed_key_id bigint;
  claimed_key_value text;
begin
  -- Find an available key for the given product and lock it for update
  select id, key_value
  into claimed_key_id, claimed_key_value
  from public.product_keys
  where product_id = p_product_id and is_used = false
  limit 1
  for update skip locked;

  -- If no key was found, raise an exception
  if claimed_key_id is null then
    raise exception 'No available keys for this product.';
  end if;

  -- Mark the key as used
  update public.product_keys
  set
    is_used = true,
    used_by_email = p_email,
    used_at = now(),
    purchase_intent_id = p_intent_id
  where id = claimed_key_id;

  -- Return the claimed key value
  return claimed_key_value;
end;
$$;

-- Grant execute permission on the function to the authenticated role
grant execute on function public.claim_available_key(uuid, text, uuid) to authenticated;
grant execute on function public.claim_available_key(uuid, text, uuid) to service_role;
